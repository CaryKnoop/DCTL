/* 
 Color Balance

 Version 003
 
 - Use perceptual luminance.
 
****************************************************************************************/

__DEVICE__ float perceptual(float3 x)
{
  x.x = x.x <= 0.081f ? x.x / 4.5f : _powf((x.x + 0.099f)/1.099f, 1.0f/0.45f);
  x.y = x.y <= 0.081f ? x.y / 4.5f : _powf((x.y + 0.099f)/1.099f, 1.0f/0.45f);
  x.z = x.z <= 0.081f ? x.z / 4.5f : _powf((x.z + 0.099f)/1.099f, 1.0f/0.45f);

  return x.x * 0.2126f + x.y * 0.7152f + x.z * 0.0722f;  
}								

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB)
{
    float R[26]   = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
    float G[26]   = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
    float B[26]   = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,
                     0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
    int   SUM[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    const float ZOOM          = 1.0f;  // Increase to ZOOM into the shadows.
    const int   SAMPLE        = 32;    // Lower for more accuracy, raise for better performance.
    const int   PANEL_COUNT   = 26;    // Defines the number of horizontal panels (25 max or increase arrays)
    const int   PANEL_SPACING = 20;    // The larger the number the smaller the height of the panels. 

    const int   skip         = SAMPLE;
    const int   skip2        = SAMPLE /2;
    const float panel_width  = (float) p_Width/PANEL_COUNT;
    const float panel_height = (float) p_Height/PANEL_SPACING;
    const float panel_zoom   = PANEL_COUNT/ZOOM;
    
    for (int i = 0; i < p_Width; i+=skip)
      for (int j = 0; j < p_Height; j+=skip2)
      {
         float3 x = make_float3(_tex2D(p_TexR, i, j),
                                _tex2D(p_TexG, i, j),
                                _tex2D(p_TexB, i, j));
         const int idx = (int) floorf(perceptual(x)*PANEL_COUNT*ZOOM);
         if (idx >= 0 && idx < PANEL_COUNT)
         {
            R[idx] += x.x;
            G[idx] += x.y;
            B[idx] += x.z;
            SUM[idx] += 1;
         }
      }
    
    if (p_Y < panel_height*(PANEL_SPACING - 1.5f))
      return make_float3(_tex2D(p_TexR, p_X, p_Y),
                         _tex2D(p_TexG, p_X, p_Y),
                         _tex2D(p_TexB, p_X, p_Y));      
    else 
    {
      int idx = (int) floorf(p_X / panel_width);
      if (p_Y < panel_height*(PANEL_SPACING - 1))
      {
         float level = (float) (2*idx+1) / (2*PANEL_COUNT*ZOOM);
         float p = level <= 0.018f ? level * 4.5f : 1.099f *_powf(level,0.45f) - 0.099f;
         return make_float3(p,p,p);
      }
      else
        if (SUM[idx] >= 1)          
          return make_float3(R[idx]/SUM[idx],G[idx]/SUM[idx],B[idx]/SUM[idx]);
        else
          if (p_Y % 2)
              return make_float3(0.3f,0.2f,0.1f);
          else
              return make_float3(0.1f,0.2f,0.3f);
    }  
}
